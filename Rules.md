# Правила Space Battle Tournament

Все правила разбиты на четыре большие категории.
- **Правила игры** - основной раздел про то, как происходит один матч. Какие есть корабли, порядок ходов и все такое.
- **Профайлер, квалификация и турнир** - порядок действий и общая структура того, к какому коду будут подключаться ваши функции.
- **Код : требования и возможности** - что вы можете и не можете использовать в коде.
- **Техническое** - детали про железо и технический пайплайн для тех, кому интересно.

Если вы первокур и не планируете выходить за рамки материала первого семестра, то достаточно прочитать первые два раздела правил.
А если что-то сильно не работает или профайлер не собирается, обратитесь к менторам.


## Правила игры

Это небольшая модификация правил морского боя.

Поле квадратное, 13х13 клеточек.

Первый игрок расставляет корабли, второй по ним стреляет, пока не собьет все корабли или пока не пройдет 169 ходов. 
Количество ходов до победы определяет количество полученных очков - чем их меньше, тем лучше. 

Корабли:
- 4 корабля 1х1;
- 3 корабля 2х1;
- 2 корабля 3х1;
- 1 корабль 4х1;
- 1 корабль 2х2 (маленькая булочка);
- 1 корабль 3х2 (большая булочка).

Символы на поле:
- 's' - корабль;
- 'o' - пустая клетка.


## Профайлер, квалификация и турнир

Вам нужно написать две функции - для расстановки своих кораблей и для стрельбы по чужим. Это и будет ваш бот.


**Вспомогательные инструменты**, которые используются в коде:

struct Point {
    int x, y;
}; // обычная структура для передачи координат на поле

enum ShotResult {
    MISS,
    HIT,
    KILL,
    WIN,
    FIRST_TURN
}; // вспомогательный тип данных, переменные которого могут принимать только описанные значения


**Функция выстрела:**

Point shoot(ShotResult previousShot); 

Вы получаете на вход результат предыдущего выстрела и можете его сохранять для последующего анализа - например, держать у себя копию поля и делать на ней пометки. 
Вернуть нужно координаты выстрела. Соответственно, его результат вы получите при следующем вызове этой функции. 

*На самом первом ходу вам будет передано значение previousShot, равное FIRST_TURN. Если вы что-то храните в глобальных массивах, тут можно сделать их инициализацию. На победном ходу вам будет передано значение WIN. Если вы использовали динамическую память, вот тут надо ее очистить.*


**Функция расстановки**

void deploy(char field[][FIELD_SIZE]);

Вам выдается массив, который надо заполнить кораблями в соответствии с правилами. Нужно использовать все корабли. Поворачивать можно. Пересекать или ставить в соседние клетки (в том числе, диагональные) нельзя. Проверка будет. 
- 'o' - пустая клетка;
- 's' - корабль.

*Если вы хотите анализировать, как по вам стрелял противник, то можете использовать содержимое массива, которое вам передается. В нем будут лежать порядковые номера выстрелов от 1 до победного. Остальные клетки заполнены нулями. В самом первом матче все клетки будут заполнены нулями.*

Допустим, вы эти функции написали или хотя бы поняли, как писать. Дальше переходим к профайлеру. 


### Профайлер

Профайлер - это программа, в которую вы можете вписать свои функции и проверить их на работоспособность на своей машине. Попробовать разные стратегии и посмотреть, как они будут работать.

Скачайте и соберите любой из профайлеров, который вам подойдет и понравится. В каждом из них есть файл Bot.h, в нем есть базовая реализация функции расстановки (deploy) и выстрела (shoot). Базовые реализации удаляете, свои вписываете на их место. Собираете профайлер со своим ботом и смотрите, как он работает. 

Обратите внимание, что бот выдает вам оценку времени хода. Вам нужно будет вписаться в его требования - если ваш код работает слишком долго, то вам придется подумать, как его оптимизировать.

### Квалификация

Когда вы более-менее уверены, что ваш бот работает, (или если уже дедлайн) вы посылаете его в наш телеграм-канал. По возможности, перед этим проверьте свой код у себя под валгриндом, чтобы ускорить процесс отладки.

Первый этап, который ваш бот должен преодолеть, это квалификация. Он должен победить квалификационного бота под валгриндом несколько раз. Победить - то есть расстреливать его корабли за меньшее число ходов. Квалификационный бот будет тот же, что и в профайлере. 

Если возникают ошибки, утечки памяти, слишком долгая работа или другие проблемы, то в том же канале вам придет соответствующее сообщение. Вы чините ошибки и отправляете исправленный вариант. Количество попыток не ограничено, но как отладчик этот телеграм-канал лучше не использовать. Медленно и неудобно, особенно если так будут делать несколько человек одновременно. Отлаживайтесь локально и посылайте только приемлемо рабочие версии.

Если ошибок нет, ваш бот зачисляется в участники турнира и ждет соперников. 

### Турнир

Детальные правила **уточняются, повесим ближе к делу**.

Предварительные правила такие.

Боты играют друг против друга каждый с каждым по несколько матчей подряд. Количество матчей будет зависеть от количества участников. Турнир будет обсчитываться на сервере, и мы хотим уложиться в 4-5 дней расчетного времени. Хотелось бы порядка 1000 матчей, чтобы большее влияние оказывал не рандом, а качество написанного алгоритма. Отсюда берутся и требования на время хода. 


## Код : требования и возможности

Что **можно** использовать:
- Глобальные переменные. Все, что вы напишете в Bot.h, будет вклеено в код профайлера и турнира. Соответственно, глобальные переменные тоже.
- Статические переменные. Так же, как и глобальные.
- Кучу. Главное - корректно ее потом почистите, квалификация будет проходить под валгриндом. 
- STL C++17. 

Что **нельзя** использовать:
- Ввод-вывод. Для отладки можете делать что угодно, но не забудьте все удалить перед посылкой.
- Системные вызовы. Библиотеки windows.h, cstdlib, unistd.h будут от вас закрыты. Это из соображений безопасности, чтобы можно было делать проверку кода автоматизированно. 
- Файлы. 

## Техническое

**тут будет описание железа, версии компилятора и характерных времен на все этапы**
